package projctx.famazing.utility;

import android.Manifest;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.net.Uri;
import android.os.IBinder;
import android.preference.PreferenceManager;
import android.support.annotation.Nullable;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.NotificationCompat;
import android.util.Log;
import android.widget.Toast;

import com.google.android.gms.maps.model.LatLng;

import java.sql.Date;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Timer;
import java.util.TimerTask;

import projctx.famazing.R;
import projctx.famazing.data.Alert;
import projctx.famazing.data.DAO;
import projctx.famazing.data.DAOEventListener;
import projctx.famazing.data.SQLRuntimeException;
import projctx.famazing.ui.AlertMapActivity;
import projctx.famazing.ui.CookieActivity;
import projctx.famazing.ui.HomeActivity;

/**
 * Service responsible of intercepting outgoing calls and send an alert message if the number called is the emergency one.
 * Plus, this service also polls the database for new alerts generated by the other members of the family and, if so, generates a notification for the user.
 */
public class AlertService extends Service implements DAOEventListener {

    private SharedPreferences preferences;
    private OutgoingCallsBroadcastReceiver callsBroadcastReceiver;
    private DAO dao;

    private List<Alert> lastAlertsFetched;

    private TimerTask task;
    private Timer timer;

    public static boolean running;

    public static final long ALERT_REFRESH_TIME = 1000 * 30;     //60 s

    private boolean connectedToFetch = true;

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        callsBroadcastReceiver = new OutgoingCallsBroadcastReceiver();
        preferences = PreferenceManager.getDefaultSharedPreferences(this);
        dao = new DAO(this);

        task = new TimerTask() {
            @Override
            public void run() {
                Log.d("TAG", "Task executed!");
                if (!dao.isConnected()) {
                    connectedToFetch = true;
                    dao.connect();
                } else {
                    fetchNewAlert();
                }
            }
        };
        timer = new Timer();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
            running = true;
            timer.schedule(task, 0, ALERT_REFRESH_TIME);
            registerReceiver(callsBroadcastReceiver, new IntentFilter(Intent.ACTION_NEW_OUTGOING_CALL));
            Log.w("TAG", "Alert service started!");
        }
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void handleConnectionEvent(@Nullable SQLRuntimeException e) {
        if (e == null) {
            Log.d("TAG", "Handle connection event ok!");
            if (!connectedToFetch) {
                int userId = PreferenceManager.getDefaultSharedPreferences(this).getInt(CookieActivity.USER_ID_KEY, -1);
                Date actualDate = new Date(System.currentTimeMillis());
                LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
                LatLng location = null;
                if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                    Location lastLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
                    if (lastLocation != null) {
                        Log.w("TAG", "Last position retreived. Broadcasting the new alert");
                        location = new LatLng(lastLocation.getLatitude(), lastLocation.getLongitude());
                    }
                }
                if (location != null) {
                    dao.createNewAlert(new Alert(null, userId, actualDate, location));
                }
            } else {
                fetchNewAlert();
            }
        } else {
            Log.d("TAG", "Connection error");
        }
    }

    @Override
    public void handleDisconnectionEvent(@Nullable SQLRuntimeException e) {}

    @Override
    public void handleResult(HashMap<String, Object> result) {
        Object res = result.get(DAO.RESULT_OBJECT_KEY);

        if (res.getClass() != SQLRuntimeException.class) {
            int operationCode = (Integer) result.get(DAO.OPERATION_CODE_KEY);

            switch (operationCode) {
                case DAO.CREATE_ALERT_CODE: {
                    if (dao.isConnected()) {
                        dao.disconnect();
                    }
                    Toast.makeText(this, "Alert sent! Keep strong!", Toast.LENGTH_SHORT).show();
                    break;
                }
                case DAO.GET_ALERTS_CODE: {
                    Log.d("TAG", "Get alerts handle result");
                    ArrayList<Alert> alerts = (ArrayList<Alert>) res;
                    if (lastAlertsFetched != null) {
                        if (lastAlertsFetched.size() != alerts.size()) {        //If there is at least one new alert...
                            Alert newAlert = alerts.get(alerts.size() - 1);
                            //We are sure there is the value, otherwise the service wouldn't be running. Send notification to the other users except who craeted the alert.
                            if (newAlert.getUserId() != PreferenceManager.getDefaultSharedPreferences(this).getInt(CookieActivity.USER_ID_KEY, -1)) {
                                sendAlertNotification(newAlert);
                            }
                        }
                        lastAlertsFetched = alerts;
                    } else {
                        lastAlertsFetched = alerts;
                    }
                    if (dao.isConnected()) {
                        dao.disconnect();
                    }
                    break;
                }
            }
        } else {
            Log.d("TAG", "Handle result connection error!");
        }
    }

    //Receiver that intercepts the outgoing calls and starts a connection with the database.
    private class OutgoingCallsBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
                String emergencyNumber = preferences.getString(CookieActivity.EMERGENCY_NUMBER_KEY, null);
                String numberCalled = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
                Log.w("TAG", String.format("Outgoing call towards number : %s found!", numberCalled));
                if (emergencyNumber != null && numberCalled.equals(emergencyNumber)) {
                    Log.w("TAG", "Number is the same as the emergency one!");
                    setResultData(null);
                    if (!dao.isConnected()) {
                        connectedToFetch = false;
                        dao.connect();
                    }
                }
            }
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        unregisterReceiver(callsBroadcastReceiver);
        if (timer != null) {
            timer.cancel();
            timer = null;
            task = null;
        }
        running = false;
        Log.w("TAG", "Alert service destroyed!");
    }

    private void fetchNewAlert() {
        Log.d("TAG", "Fetching new alerts");
        int familyId = PreferenceManager.getDefaultSharedPreferences(this).getInt(CookieActivity.USER_FAMILY_KEY, -1);
        if (familyId != -1) {
            dao.getFamilyAlerts(familyId);
        } else {
            dao.disconnect();
        }
    }

    private void sendAlertNotification(Alert alert) {
        Log.d("TAG", "Creating alert cause new alert was found.");
        Intent alertEvent = new Intent(this, AlertMapActivity.class);
        alertEvent.putExtra(AlertMapActivity.USER_ID_INTENT_KEY, alert.getUserId());
        alertEvent.putExtra(AlertMapActivity.ALERT_DATE_INTENT_KEY, alert.getAlertDate());
        alertEvent.putExtra(AlertMapActivity.ALERT_LOCATION_INTENT_KEY, new double[] {alert.getUserLocation().latitude, alert.getUserLocation().longitude});
        PendingIntent alertPendingIntent = PendingIntent.getActivity(this, 0, alertEvent, PendingIntent.FLAG_UPDATE_CURRENT);
        NotificationCompat.Builder nBuilder = new NotificationCompat.Builder(this).setContentTitle("NEW ALERT!")
                .setContentText("A new alert has been created by a family member!").setSmallIcon(R.drawable.alert_icon)
                .setPriority(Notification.PRIORITY_HIGH).setDefaults(Notification.DEFAULT_ALL);

        nBuilder.setContentIntent(alertPendingIntent);
        ((NotificationManager) getSystemService(NOTIFICATION_SERVICE)).notify(0, nBuilder.build());
    }
}